import { fal } from '@fal-ai/client';
import OpenAI from 'openai';
import { GenerationSettings, FalApiResult, GeneratedImage, ModelType, GenerationLogEntry } from './types';
import { addGenerationLog, getGenerationLogsByProject } from './storage';

// Debug API key loading
console.log('API Key Debug:', {
  hasWindow: typeof window !== 'undefined',
  envKey: process.env.NEXT_PUBLIC_FAL_KEY,
  envKeyLength: process.env.NEXT_PUBLIC_FAL_KEY?.length
});

// Get API key from localStorage or environment
function getApiKey(): string | null {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('fal_api_key') || process.env.NEXT_PUBLIC_FAL_KEY || null;
  }
  return process.env.NEXT_PUBLIC_FAL_KEY || null;
}

// Get OpenAI API key from localStorage or environment
function getOpenAIApiKey(): string | null {
  if (typeof window !== 'undefined') {
    return localStorage.getItem('openai_api_key') || process.env.NEXT_PUBLIC_OPENAI_API_KEY || null;
  }
  return process.env.NEXT_PUBLIC_OPENAI_API_KEY || null;
}

// Configure fal.ai client
function configureFalClient() {
  const apiKey = getApiKey();
  if (apiKey) {
    console.log('Configuring fal.ai with API key:', apiKey.substring(0, 10) + '...');
    fal.config({
      credentials: apiKey,
    });
    return true;
  } else {
    console.error('No API key found! Please configure it in settings.');
    return false;
  }
}

// Configure OpenAI client
function configureOpenAIClient(): OpenAI | null {
  const apiKey = getOpenAIApiKey();
  if (apiKey) {
    console.log('Configuring OpenAI with API key:', apiKey.substring(0, 10) + '...');
    return new OpenAI({
      apiKey: apiKey,
      dangerouslyAllowBrowser: true, // Required for browser usage
    });
  } else {
    console.error('No OpenAI API key found! Please configure it in settings.');
    return null;
  }
}

// Initialize on client side
if (typeof window !== 'undefined') {
  configureFalClient();
}

export interface GenerateImageOptions {
  prompt: string;
  settings: GenerationSettings;
  onProgress?: (update: any) => void;
}

// Convert aspect ratio to OpenAI size format
function aspectRatioToOpenAISize(aspectRatio: string): string {
  switch (aspectRatio) {
    case '1:1':
      return '1024x1024';
    case '16:9':
    case '21:9':
      return '1536x1024'; // Landscape
    case '4:3':
    case '3:2':
      return '1536x1024'; // Landscape
    case '4:3-custom':
      return '1536x1024'; // Landscape - OpenAI doesn't support custom sizes, so use standard 4:3
    case '9:16':
    case '2:3':
    case '3:4':
      return '1024x1536'; // Portrait
    default:
      return '1024x1024';
  }
}

// Generate image with OpenAI
async function generateWithOpenAI(options: GenerateImageOptions): Promise<FalApiResult> {
  const { prompt, settings } = options;
  
  const client = configureOpenAIClient();
  if (!client) {
    throw new Error('OpenAI API key not configured. Please add your OpenAI API key in settings.');
  }

  console.log(`üé® Generating with GPT Image 1:`, { 
    prompt: prompt.substring(0, 50) + '...',
    settings: {
      size: aspectRatioToOpenAISize(settings.aspectRatio),
      n: settings.numImages,
      background: settings.openaiBackground || 'auto',
      quality: settings.openaiQuality || 'auto',
      output_format: settings.openaiOutputFormat || 'png'
    }
  });

  try {
    const response = await client.images.generate({
      model: 'gpt-image-1',
      prompt: prompt.trim(),
      n: settings.numImages,
      size: aspectRatioToOpenAISize(settings.aspectRatio) as any,
      background: settings.openaiBackground || 'auto',
      quality: settings.openaiQuality || 'auto',
      output_format: settings.openaiOutputFormat || 'png',
    });

    console.log(`‚úÖ GPT Image 1 generation successful`);

    // Convert OpenAI response to our format
    if (!response.data || response.data.length === 0) {
      throw new Error('No images generated by OpenAI');
    }

    const images = response.data.map((img, index) => {
      // Convert base64 to blob URL
      const base64Data = img.b64_json!;
      const mimeType = `image/${settings.openaiOutputFormat || 'png'}`;
      const blob = new Blob([Buffer.from(base64Data, 'base64')], { type: mimeType });
      const url = URL.createObjectURL(blob);
      
      return {
        url: url,
        file_name: `gpt-image-1-${Date.now()}-${index}.${settings.openaiOutputFormat || 'png'}`,
        file_size: blob.size,
        content_type: mimeType,
      };
    });

    return {
      data: { images },
      requestId: `openai-${Date.now()}`,
    } as FalApiResult;
  } catch (error) {
    console.error(`‚ùå GPT Image 1 generation failed:`, error);
    throw error;
  }
}

export async function generateImage(options: GenerateImageOptions): Promise<FalApiResult> {
  const { prompt, settings, onProgress } = options;

  // Handle OpenAI GPT Image 1
  if (settings.model === 'gpt-image-1') {
    return generateWithOpenAI(options);
  }

  // Handle FAL.ai models (minimax, imagen4, imagen4-fast, seedream, seedream-v4, nano-banana)
  try {
    // Determine the model endpoint and input parameters
    const endpoint = settings.model === 'imagen4' ? 'fal-ai/imagen4/preview' 
      : settings.model === 'imagen4-fast' ? 'fal-ai/imagen4/preview/fast'
      : settings.model === 'seedream' ? 'fal-ai/bytedance/seedream/v3/text-to-image'
      : settings.model === 'seedream-v4' ? 'fal-ai/bytedance/seedream/v4/text-to-image'
      : settings.model === 'nano-banana' ? 'fal-ai/nano-banana'
      : 'fal-ai/minimax/image-01';
    
    // Base input parameters common to most models
    const baseInput = {
      prompt: prompt.trim(),
      aspect_ratio: settings.aspectRatio,
      num_images: settings.numImages,
    };

    // Add model-specific parameters
    let input;
    if (settings.model === 'minimax') {
      input = { ...baseInput, prompt_optimizer: settings.promptOptimizer };
    } else if (settings.model === 'seedream') {
      // Handle custom size for seedream
      if (settings.aspectRatio === '4:3-custom') {
        input = { 
          prompt: prompt.trim(),
          image_size: {
            width: 2048,
            height: 1536
          },
          num_images: settings.numImages,
          guidance_scale: settings.guidanceScale || 2.5 
        };
      } else {
        input = { ...baseInput, guidance_scale: settings.guidanceScale || 2.5 };
      }
    } else if (settings.model === 'seedream-v4') {
      // Seedream v4 with fixed 5120x3840 size
      input = { 
        prompt: prompt.trim(),
        image_size: {
          width: 5120,
          height: 3840
        },
        num_images: settings.numImages,
        guidance_scale: settings.guidanceScale || 2.5 
      };
    } else if (settings.model === 'imagen4' || settings.model === 'imagen4-fast') {
      // Imagen 4 Preview with resolution option
      // Imagen 4 only supports: 1:1, 16:9, 9:16, 4:3, 3:4
      // Map unsupported aspect ratios to closest supported ones
      const mapAspectRatio = (ratio: string): string => {
        const mapping: Record<string, string> = {
          '1:1': '1:1',
          '16:9': '16:9',
          '9:16': '9:16',
          '4:3': '4:3',
          '3:4': '3:4',
          '3:2': '16:9',      // Map 3:2 landscape to 16:9
          '2:3': '9:16',      // Map 2:3 portrait to 9:16
          '21:9': '16:9',     // Map ultra-wide to 16:9
          '5:4': '4:3',       // Map 5:4 to 4:3
          '4:5': '3:4',       // Map 4:5 to 3:4
          '4:3-custom': '4:3' // Map custom to standard 4:3
        };
        return mapping[ratio] || '1:1';
      };
      
      input = { 
        prompt: prompt.trim(),
        aspect_ratio: mapAspectRatio(settings.aspectRatio),
        num_images: settings.numImages,
        resolution: settings.imagen4Resolution || '1K',
        output_format: 'png'
      };
    } else if (settings.model === 'nano-banana') {
      // Nano Banana supports: 21:9, 16:9, 3:2, 4:3, 5:4, 1:1, 4:5, 3:4, 2:3, 9:16
      // Handle custom size option by mapping to closest standard ratio
      const mapAspectRatio = (ratio: string): string => {
        if (ratio === '4:3-custom') return '4:3';
        return ratio;
      };
      
      input = { 
        prompt: prompt.trim(),
        aspect_ratio: mapAspectRatio(settings.aspectRatio),
        num_images: settings.numImages,
        output_format: 'png'
      };
    } else {
      // minimax and other models
      input = baseInput;
    }

    console.log(`üé® Generating with ${settings.model}:`, { endpoint, input });

    const result = await fal.subscribe(endpoint, {
      input,
      logs: true,
      onQueueUpdate: (update) => {
        if (onProgress) {
          onProgress(update);
        }
        if (update.status === 'IN_PROGRESS') {
          update.logs?.map((log: any) => log.message).forEach(console.log);
        }
      },
    });

    console.log(`‚úÖ ${settings.model} generation successful:`, { requestId: result.requestId });
    return result as FalApiResult;
  } catch (error) {
    console.error(`‚ùå ${settings.model} generation failed:`, error);
    
    // Enhanced error handling for imagen4, imagen4-fast, seedream, seedream-v4, and nano-banana content moderation
    if ((settings.model === 'imagen4' || settings.model === 'imagen4-fast' || settings.model === 'seedream' || settings.model === 'seedream-v4' || settings.model === 'nano-banana') && error instanceof Error) {
      if (error.message.includes('400') || error.message.toLowerCase().includes('moderation') || 
          error.message.toLowerCase().includes('content policy') || error.message.toLowerCase().includes('safety')) {
        const modelName = settings.model === 'imagen4-fast' ? 'Imagen4 Fast' 
          : settings.model === 'seedream' ? 'Seedream' 
          : settings.model === 'seedream-v4' ? 'Seedream v4'
          : settings.model === 'nano-banana' ? 'Nano Banana'
          : 'Imagen4';
        throw new Error(`${modelName} content moderation rejected your prompt. The image content may have been flagged as potentially inappropriate. Try rephrasing your prompt or using the Minimax model instead.`);
      }
    }
    
    throw new Error(error instanceof Error ? error.message : 'Failed to generate image');
  }
}

// New function: Generate image with automatic fallback
export interface GenerateImageWithFallbackResult {
  data: FalApiResult['data'];
  requestId: string;
  modelUsed: ModelType;
  wasFallback: boolean;
}

export async function generateImageWithFallback(options: GenerateImageOptions): Promise<GenerateImageWithFallbackResult> {
  const { prompt, settings, onProgress } = options;
  
  try {
    // First attempt with the selected model
    console.log(`üéØ Attempting generation with ${settings.model} for prompt: "${prompt.substring(0, 50)}..."`);
    const result = await generateImage(options);
    
    return {
      data: result.data,
      requestId: result.requestId,
      modelUsed: settings.model,
      wasFallback: false,
    };
  } catch (error) {
    console.warn(`‚ö†Ô∏è ${settings.model} failed:`, error instanceof Error ? error.message : 'Unknown error');
    console.log(`üîç Error details:`, error);
    
    // Enhanced error detection for content moderation
    const errorMessage = error instanceof Error ? error.message.toLowerCase() : '';
    const errorString = JSON.stringify(error).toLowerCase();
    
    const isContentModerationError = (settings.model === 'imagen4' || settings.model === 'imagen4-fast' || settings.model === 'seedream' || settings.model === 'nano-banana') && (
      errorMessage.includes('400') ||
      errorMessage.includes('moderation') ||
      errorMessage.includes('content policy') ||
      errorMessage.includes('safety') ||
      errorMessage.includes('blocked') ||
      errorMessage.includes('inappropriate') ||
      errorMessage.includes('violation') ||
      errorMessage.includes('rejected') ||
      errorString.includes('400') ||
      errorString.includes('moderation') ||
      errorString.includes('content') ||
      errorString.includes('safety')
    );
    
    console.log(`üîç Error analysis:`, {
      model: settings.model,
      fallbackEnabled: settings.enableFallback,
      isContentModerationError,
      errorMessage: errorMessage.substring(0, 200),
      willAttemptFallback: settings.enableFallback && isContentModerationError
    });
    
    // Attempt fallback for any Imagen4, Imagen4-Fast, Seedream, or Nano Banana error when fallback is enabled
    // This makes it more robust - if these models fail for any reason, try Minimax
    // Note: GPT Image 1 doesn't support fallback due to different API structure
    const shouldAttemptFallback = (settings.model === 'imagen4' || settings.model === 'imagen4-fast' || settings.model === 'seedream' || settings.model === 'nano-banana') && settings.enableFallback;
    
    if (shouldAttemptFallback) {
      console.log(`üîÑ Attempting fallback to Minimax for prompt: "${prompt.substring(0, 50)}..." (Reason: ${isContentModerationError ? 'Content moderation' : 'General error'})`);
      
      try {
        // Create fallback settings
        const fallbackSettings: GenerationSettings = {
          model: 'minimax',
          aspectRatio: settings.aspectRatio, // Inherit aspect ratio
          numImages: settings.numImages,     // Inherit number of images
          promptOptimizer: false,            // Always false for fallback
          enableFallback: settings.enableFallback,
        };
        
        // Attempt generation with fallback model
        const fallbackResult = await generateImage({
          prompt,
          settings: fallbackSettings,
          onProgress,
        });
        
        console.log(`‚úÖ Fallback to Minimax successful for prompt: "${prompt.substring(0, 50)}..."`);
        
        return {
          data: fallbackResult.data,
          requestId: fallbackResult.requestId,
          modelUsed: 'minimax',
          wasFallback: true,
        };
      } catch (fallbackError) {
        console.error(`‚ùå Fallback to Minimax also failed:`, fallbackError);
        throw new Error(`Both ${settings.model} and Minimax fallback failed. Original error: ${error instanceof Error ? error.message : 'Unknown error'}. Fallback error: ${fallbackError instanceof Error ? fallbackError.message : 'Unknown error'}`);
      }
    } else {
      // No fallback or not using Imagen4/Imagen4-Fast/Seedream/Nano Banana
      if ((settings.model === 'imagen4' || settings.model === 'imagen4-fast' || settings.model === 'seedream' || settings.model === 'nano-banana') && !settings.enableFallback) {
        console.log(`‚ÑπÔ∏è Fallback is disabled, not attempting retry`);
      } else if (settings.model !== 'imagen4' && settings.model !== 'imagen4-fast' && settings.model !== 'seedream' && settings.model !== 'nano-banana') {
        console.log(`‚ÑπÔ∏è Using ${settings.model}, no fallback needed`);
      }
      throw error;
    }
  }
}

export async function generateMultipleImages(
  prompts: string[],
  settings: GenerationSettings,
  projectId: string,
  onProgress?: (completed: number, total: number, currentPrompt?: string, fallbackInfo?: string) => void,
  onImageComplete?: (image: GeneratedImage) => void,
  sessionId?: string
): Promise<{ completed: GeneratedImage[]; errors: string[]; fallbackCount: number; sessionId: string }> {
  const completed: GeneratedImage[] = [];
  const errors: string[] = [];
  let fallbackCount = 0;
  
  // Generate a session ID for this batch if not provided
  const currentSessionId = sessionId || crypto.randomUUID();

  // Get the highest attempt number from existing logs for this project
  const existingLogs = await getGenerationLogsByProject(projectId);
  const highestAttemptNumber = existingLogs.length > 0 
    ? Math.max(...existingLogs.map(log => log.attemptNumber)) 
    : 0;
  
  console.log(`üöÄ Starting batch generation of ${prompts.length} prompts with ${settings.model}`);
  console.log(`üìã Settings:`, settings);

  for (let i = 0; i < prompts.length; i++) {
    const prompt = prompts[i].trim();
    if (!prompt) continue;

    try {
      onProgress?.(i, prompts.length, prompt);

      console.log(`üìù Processing prompt ${i + 1}/${prompts.length}: "${prompt.substring(0, 100)}..."`);

      const result = await generateImageWithFallback({
        prompt,
        settings,
        onProgress: (update) => {
          // Optional: Could emit more granular progress here
        },
      });

      if (result.wasFallback) {
        fallbackCount++;
        onProgress?.(i, prompts.length, prompt, `Using Minimax fallback (${fallbackCount} fallbacks so far)`);
        console.log(`üîÑ Fallback used for prompt ${i + 1}. Total fallbacks: ${fallbackCount}`);
      }

      // Convert fal.ai response to our format
      if (result.data?.images?.length > 0) {
        for (const falImage of result.data.images) {
          const generatedImage: GeneratedImage = {
            id: crypto.randomUUID(),
            projectId,
            prompt,
            url: falImage.url,
            fileName: falImage.file_name,
            fileSize: falImage.file_size,
            contentType: falImage.content_type,
            createdAt: new Date().toISOString(),
            aspectRatio: settings.aspectRatio,
            requestId: result.requestId,
            modelUsed: result.modelUsed,
            wasFallback: result.wasFallback,
          };

          completed.push(generatedImage);
          onImageComplete?.(generatedImage);
          
          // Log successful generation
          const logEntry: GenerationLogEntry = {
            id: crypto.randomUUID(),
            projectId,
            sessionId: currentSessionId,
            attemptNumber: highestAttemptNumber + i + 1,
            prompt,
            status: 'success',
            generatedImage,
            modelUsed: result.modelUsed,
            wasFallback: result.wasFallback,
            createdAt: new Date().toISOString(),
          };
          await addGenerationLog(logEntry);
          
          console.log(`‚úÖ Image generated successfully with ${result.modelUsed}${result.wasFallback ? ' (fallback)' : ''}`);
        }
      }
    } catch (error) {
      const errorMessage = `Failed to generate image for prompt "${prompt.substring(0, 50)}...": ${
        error instanceof Error ? error.message : 'Unknown error'
      }`;
      errors.push(errorMessage);
      
      // Log failed generation
      const logEntry: GenerationLogEntry = {
        id: crypto.randomUUID(),
        projectId,
        sessionId: currentSessionId,
        attemptNumber: highestAttemptNumber + i + 1,
        prompt,
        status: 'failed',
        error: error instanceof Error ? error.message : 'Unknown error',
        modelUsed: settings.model,
        createdAt: new Date().toISOString(),
      };
      await addGenerationLog(logEntry);
      
      console.error(`‚ùå Error for prompt ${i + 1}:`, errorMessage);
    }

    // Small delay between requests to avoid rate limiting
    if (i < prompts.length - 1) {
      await new Promise(resolve => setTimeout(resolve, 1000));
    }
  }

  onProgress?.(prompts.length, prompts.length);
  
  console.log(`üèÅ Batch generation complete:`);
  console.log(`  ‚úÖ Successful: ${completed.length} images`);
  console.log(`  ‚ùå Errors: ${errors.length}`);
  console.log(`  üîÑ Fallbacks used: ${fallbackCount}`);
  
  return { completed, errors, fallbackCount, sessionId: currentSessionId };
}

export function parsePromptsFromText(text: string): string[] {
  return text
    .split('\n')
    .map(line => line.trim())
    .filter(line => line.length > 0 && !line.startsWith('#'));
}

export async function downloadImageAsBlob(url: string): Promise<Blob> {
  const response = await fetch(url);
  if (!response.ok) {
    throw new Error(`Failed to download image: ${response.statusText}`);
  }
  return response.blob();
}

// Validate API key
export function validateApiKey(): boolean {
  return !!(process.env.NEXT_PUBLIC_FAL_KEY || (typeof window !== 'undefined' && localStorage.getItem('fal_api_key')));
}

// Validate OpenAI API key
export function validateOpenAIApiKey(): boolean {
  return !!(process.env.NEXT_PUBLIC_OPENAI_API_KEY || (typeof window !== 'undefined' && localStorage.getItem('openai_api_key')));
}

// Set API key dynamically (for development)
export function setApiKey(apiKey: string): void {
  if (typeof window !== 'undefined') {
    localStorage.setItem('fal_api_key', apiKey);
    fal.config({
      credentials: apiKey,
    });
  }
}

// Set OpenAI API key dynamically
export function setOpenAIApiKey(apiKey: string): void {
  if (typeof window !== 'undefined') {
    localStorage.setItem('openai_api_key', apiKey);
  }
} 